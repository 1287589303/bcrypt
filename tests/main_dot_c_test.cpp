/*
 * This file is automatically generated by UnitTestBot. For further information see https://www.utbot.org
 */

#include "main_dot_c_test.h"

#include "gtest/gtest.h"

char * optarg;
int optind;
namespace UTBot {


#pragma region regression
TEST(regression, initoptions_test1)
{
    struct _BCoptions actual = initoptions({
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 99
    });
    struct _BCoptions expected = {
        .remove = 1,
        .standardout = 0,
        .compression = 1,
        .type = 127,
        .origsize = 0UL,
        .securedelete = 3
    };
}

TEST(regression, usage_test1)
{
    char name[] = {'a', 'c', 'a', 'a', 'a', 'c', 'a', 'c', 'a', '\0'};
    int actual = usage(name);
    EXPECT_EQ(0, actual);
    char expected_name[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_118_0 = 0; it_118_0 < 10; it_118_0 ++) {
        EXPECT_EQ(expected_name[it_118_0], name[it_118_0]);
    }
}

TEST(regression, memerror_test1)
{
    int actual = memerror();
    EXPECT_EQ(0, actual);
}

TEST(regression, parseArgs_test1)
{
    char optarg_buffer[] = "ccacaccaa";
    optarg = optarg_buffer;
    optind = 2;
    int argc = 0;
    char _argv[2][2] = {{'\0', 'c'}, {'a', 'a'}};
    char ** argv = (char **) calloc(3, sizeof(char *));
    for (int it_119_0 = 0; it_119_0 < 2; it_119_0 ++) {
        argv[it_119_0] = _argv[it_119_0];
    }
    argv[2] = NULL;
    struct _BCoptions options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 99
    };
    int actual = parseArgs(&argc, argv, &options);
    EXPECT_EQ(0, actual);
    char expected_optarg = '\0';
    EXPECT_EQ(expected_optarg, (*optarg));
    int expected_optind = 0;
    EXPECT_EQ(expected_optind, optind);
    int expected_argc = 0;
    EXPECT_EQ(expected_argc, argc);
    char expected_argv[2][2] = {{'\0', '\0'}, {'\0', '\0'}};
    for (int it_120_0 = 0; it_120_0 < 2; it_120_0 ++) {
        for (int it_120_1 = 0; it_120_1 < 2; it_120_1 ++) {
            EXPECT_EQ(expected_argv[it_120_0][it_120_1], _argv[it_120_0][it_120_1]);
        }
    }
    struct _BCoptions expected_options = {
        .remove = 0,
        .standardout = 0,
        .compression = 0,
        .type = 0,
        .origsize = 0UL,
        .securedelete = 0
    };
    EXPECT_EQ(expected_options.remove, options.remove);
    EXPECT_EQ(expected_options.standardout, options.standardout);
    EXPECT_EQ(expected_options.compression, options.compression);
    EXPECT_EQ(expected_options.type, options.type);
    EXPECT_EQ(expected_options.origsize, options.origsize);
    EXPECT_EQ(expected_options.securedelete, options.securedelete);
}

TEST(regression, parseArgs_test2)
{
    char optarg_buffer[] = "ccacaccaa";
    optarg = optarg_buffer;
    optind = -5;
    int argc = 0;
    char _argv[2][2] = {{'\0', 'c'}, {'c', 'c'}};
    char ** argv = (char **) calloc(3, sizeof(char *));
    for (int it_121_0 = 0; it_121_0 < 2; it_121_0 ++) {
        argv[it_121_0] = _argv[it_121_0];
    }
    argv[2] = NULL;
    struct _BCoptions options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 99
    };
    int actual = parseArgs(&argc, argv, &options);
    EXPECT_EQ(-5, actual);
    char expected_optarg = 'c';
    EXPECT_EQ(expected_optarg, (*optarg));
    int expected_optind = -5;
    EXPECT_EQ(expected_optind, optind);
    int expected_argc = 5;
    EXPECT_EQ(expected_argc, argc);
    char expected_argv[2][2] = {{'\0', 'c'}, {'c', 'c'}};
    for (int it_122_0 = 0; it_122_0 < 2; it_122_0 ++) {
        for (int it_122_1 = 0; it_122_1 < 2; it_122_1 ++) {
            EXPECT_EQ(expected_argv[it_122_0][it_122_1], _argv[it_122_0][it_122_1]);
        }
    }
    struct _BCoptions expected_options = {
        .remove = 1,
        .standardout = 0,
        .compression = 1,
        .type = 127,
        .origsize = 0UL,
        .securedelete = 3
    };
    EXPECT_EQ(expected_options.remove, options.remove);
    EXPECT_EQ(expected_options.standardout, options.standardout);
    EXPECT_EQ(expected_options.compression, options.compression);
    EXPECT_EQ(expected_options.type, options.type);
    EXPECT_EQ(expected_options.origsize, options.origsize);
    EXPECT_EQ(expected_options.securedelete, options.securedelete);
}

TEST(regression, assignFiles_test1)
{
    char arg[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    char _infile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** infile = (char **) calloc(3, sizeof(char *));
    for (int it_123_0 = 0; it_123_0 < 2; it_123_0 ++) {
        infile[it_123_0] = _infile[it_123_0];
    }
    infile[2] = NULL;
    char _outfile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** outfile = (char **) calloc(3, sizeof(char *));
    for (int it_124_0 = 0; it_124_0 < 2; it_124_0 ++) {
        outfile[it_124_0] = _outfile[it_124_0];
    }
    outfile[2] = NULL;
    struct stat statbuf = {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = 0,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = 0L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = 0L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = 0L
        },
        .__glibc_reserved = {0L, 0L, 0L}
    };
    struct _BCoptions options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 0UL,
        .securedelete = 99
    };
    char key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    int actual = assignFiles(arg, infile, outfile, &statbuf, &options, key);
    EXPECT_EQ(1, actual);
    char expected_arg[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_125_0 = 0; it_125_0 < 10; it_125_0 ++) {
        EXPECT_EQ(expected_arg[it_125_0], arg[it_125_0]);
    }
    char expected_infile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    for (int it_126_0 = 0; it_126_0 < 2; it_126_0 ++) {
        for (int it_126_1 = 0; it_126_1 < 2; it_126_1 ++) {
            EXPECT_EQ(expected_infile[it_126_0][it_126_1], _infile[it_126_0][it_126_1]);
        }
    }
    char expected_outfile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    for (int it_127_0 = 0; it_127_0 < 2; it_127_0 ++) {
        for (int it_127_1 = 0; it_127_1 < 2; it_127_1 ++) {
            EXPECT_EQ(expected_outfile[it_127_0][it_127_1], _outfile[it_127_0][it_127_1]);
        }
    }
    struct stat expected_statbuf = {
        .st_dev = 2049UL,
        .st_ino = 1UL,
        .st_nlink = 1UL,
        .st_mode = 420U,
        .st_uid = 1001U,
        .st_gid = 127U,
        .__pad0 = 0,
        .st_rdev = 0UL,
        .st_size = 64L,
        .st_blksize = 4096L,
        .st_blocks = 8L,
        .st_atim = {
            .tv_sec = 1720683629L,
            .tv_nsec = 0L
        },
        .st_mtim = {
            .tv_sec = 1720683629L,
            .tv_nsec = 0L
        },
        .st_ctim = {
            .tv_sec = 1720683629L,
            .tv_nsec = 0L
        },
        .__glibc_reserved = {0L, 0L, 0L}
    };
    EXPECT_EQ(expected_statbuf.st_dev, statbuf.st_dev);
    EXPECT_EQ(expected_statbuf.st_ino, statbuf.st_ino);
    EXPECT_EQ(expected_statbuf.st_nlink, statbuf.st_nlink);
    EXPECT_EQ(expected_statbuf.st_mode, statbuf.st_mode);
    EXPECT_EQ(expected_statbuf.st_uid, statbuf.st_uid);
    EXPECT_EQ(expected_statbuf.st_gid, statbuf.st_gid);
    EXPECT_EQ(expected_statbuf.__pad0, statbuf.__pad0);
    EXPECT_EQ(expected_statbuf.st_rdev, statbuf.st_rdev);
    EXPECT_EQ(expected_statbuf.st_size, statbuf.st_size);
    EXPECT_EQ(expected_statbuf.st_blksize, statbuf.st_blksize);
    EXPECT_EQ(expected_statbuf.st_blocks, statbuf.st_blocks);
    EXPECT_EQ(expected_statbuf.st_atim.tv_sec, statbuf.st_atim.tv_sec);
    EXPECT_EQ(expected_statbuf.st_atim.tv_nsec, statbuf.st_atim.tv_nsec);
    EXPECT_EQ(expected_statbuf.st_mtim.tv_sec, statbuf.st_mtim.tv_sec);
    EXPECT_EQ(expected_statbuf.st_mtim.tv_nsec, statbuf.st_mtim.tv_nsec);
    EXPECT_EQ(expected_statbuf.st_ctim.tv_sec, statbuf.st_ctim.tv_sec);
    EXPECT_EQ(expected_statbuf.st_ctim.tv_nsec, statbuf.st_ctim.tv_nsec);
    for (int it_128_0 = 0; it_128_0 < 3; it_128_0 ++) {
        EXPECT_EQ(expected_statbuf.__glibc_reserved[it_128_0], statbuf.__glibc_reserved[it_128_0]);
    }
    struct _BCoptions expected_options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 0UL,
        .securedelete = 99
    };
    EXPECT_EQ(expected_options.remove, options.remove);
    EXPECT_EQ(expected_options.standardout, options.standardout);
    EXPECT_EQ(expected_options.compression, options.compression);
    EXPECT_EQ(expected_options.type, options.type);
    EXPECT_EQ(expected_options.origsize, options.origsize);
    EXPECT_EQ(expected_options.securedelete, options.securedelete);
    char expected_key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_129_0 = 0; it_129_0 < 10; it_129_0 ++) {
        EXPECT_EQ(expected_key[it_129_0], key[it_129_0]);
    }
}

TEST(regression, assignFiles_test2)
{
    char arg[] = {'d', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    char _infile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** infile = (char **) calloc(3, sizeof(char *));
    for (int it_130_0 = 0; it_130_0 < 2; it_130_0 ++) {
        infile[it_130_0] = _infile[it_130_0];
    }
    infile[2] = NULL;
    char _outfile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** outfile = (char **) calloc(3, sizeof(char *));
    for (int it_131_0 = 0; it_131_0 < 2; it_131_0 ++) {
        outfile[it_131_0] = _outfile[it_131_0];
    }
    outfile[2] = NULL;
    struct stat statbuf = {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = 0,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = 0L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = 0L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = 0L
        },
        .__glibc_reserved = {0L, 0L, 0L}
    };
    struct _BCoptions options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 0UL,
        .securedelete = 99
    };
    char key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    int actual = assignFiles(arg, infile, outfile, &statbuf, &options, key);
    EXPECT_EQ(1, actual);
    char expected_arg[] = {'d', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_132_0 = 0; it_132_0 < 10; it_132_0 ++) {
        EXPECT_EQ(expected_arg[it_132_0], arg[it_132_0]);
    }
    char expected_infile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    for (int it_133_0 = 0; it_133_0 < 2; it_133_0 ++) {
        for (int it_133_1 = 0; it_133_1 < 2; it_133_1 ++) {
            EXPECT_EQ(expected_infile[it_133_0][it_133_1], _infile[it_133_0][it_133_1]);
        }
    }
    char expected_outfile[2][2] = {{'c', 'c'}, {'c', 'c'}};
    for (int it_134_0 = 0; it_134_0 < 2; it_134_0 ++) {
        for (int it_134_1 = 0; it_134_1 < 2; it_134_1 ++) {
            EXPECT_EQ(expected_outfile[it_134_0][it_134_1], _outfile[it_134_0][it_134_1]);
        }
    }
    struct stat expected_statbuf = {
        .st_dev = 12370169555311111083UL,
        .st_ino = 12370169555311111083UL,
        .st_nlink = 12370169555311111083UL,
        .st_mode = 2880154539U,
        .st_uid = 2880154539U,
        .st_gid = 2880154539U,
        .__pad0 = 0,
        .st_rdev = 12370169555311111083UL,
        .st_size = -6076574518398440533L,
        .st_blksize = -6076574518398440533L,
        .st_blocks = -6076574518398440533L,
        .st_atim = {
            .tv_sec = -6076574518398440533L,
            .tv_nsec = 0L
        },
        .st_mtim = {
            .tv_sec = -6076574518398440533L,
            .tv_nsec = 0L
        },
        .st_ctim = {
            .tv_sec = -6076574518398440533L,
            .tv_nsec = 0L
        },
        .__glibc_reserved = {0L, 0L, 0L}
    };
    EXPECT_EQ(expected_statbuf.st_dev, statbuf.st_dev);
    EXPECT_EQ(expected_statbuf.st_ino, statbuf.st_ino);
    EXPECT_EQ(expected_statbuf.st_nlink, statbuf.st_nlink);
    EXPECT_EQ(expected_statbuf.st_mode, statbuf.st_mode);
    EXPECT_EQ(expected_statbuf.st_uid, statbuf.st_uid);
    EXPECT_EQ(expected_statbuf.st_gid, statbuf.st_gid);
    EXPECT_EQ(expected_statbuf.__pad0, statbuf.__pad0);
    EXPECT_EQ(expected_statbuf.st_rdev, statbuf.st_rdev);
    EXPECT_EQ(expected_statbuf.st_size, statbuf.st_size);
    EXPECT_EQ(expected_statbuf.st_blksize, statbuf.st_blksize);
    EXPECT_EQ(expected_statbuf.st_blocks, statbuf.st_blocks);
    EXPECT_EQ(expected_statbuf.st_atim.tv_sec, statbuf.st_atim.tv_sec);
    EXPECT_EQ(expected_statbuf.st_atim.tv_nsec, statbuf.st_atim.tv_nsec);
    EXPECT_EQ(expected_statbuf.st_mtim.tv_sec, statbuf.st_mtim.tv_sec);
    EXPECT_EQ(expected_statbuf.st_mtim.tv_nsec, statbuf.st_mtim.tv_nsec);
    EXPECT_EQ(expected_statbuf.st_ctim.tv_sec, statbuf.st_ctim.tv_sec);
    EXPECT_EQ(expected_statbuf.st_ctim.tv_nsec, statbuf.st_ctim.tv_nsec);
    for (int it_135_0 = 0; it_135_0 < 3; it_135_0 ++) {
        EXPECT_EQ(expected_statbuf.__glibc_reserved[it_135_0], statbuf.__glibc_reserved[it_135_0]);
    }
    struct _BCoptions expected_options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 0UL,
        .securedelete = 99
    };
    EXPECT_EQ(expected_options.remove, options.remove);
    EXPECT_EQ(expected_options.standardout, options.standardout);
    EXPECT_EQ(expected_options.compression, options.compression);
    EXPECT_EQ(expected_options.type, options.type);
    EXPECT_EQ(expected_options.origsize, options.origsize);
    EXPECT_EQ(expected_options.securedelete, options.securedelete);
    char expected_key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_136_0 = 0; it_136_0 < 10; it_136_0 ++) {
        EXPECT_EQ(expected_key[it_136_0], key[it_136_0]);
    }
}

TEST(regression, main_test1)
{
    char _argv[2][2] = {{'\0', 'c'}, {'c', 'c'}};
    char ** argv = (char **) calloc(3, sizeof(char *));
    for (int it_139_0 = 0; it_139_0 < 2; it_139_0 ++) {
        argv[it_139_0] = _argv[it_139_0];
    }
    argv[2] = NULL;
    int actual = main(0, argv);
    EXPECT_EQ(0, actual);
    char expected_argv[2][2] = {{'\0', '\0'}, {'\0', '\0'}};
    for (int it_140_0 = 0; it_140_0 < 2; it_140_0 ++) {
        for (int it_140_1 = 0; it_140_1 < 2; it_140_1 ++) {
            EXPECT_EQ(expected_argv[it_140_0][it_140_1], _argv[it_140_0][it_140_1]);
        }
    }
}

#pragma endregion
#pragma region error
// Error: memory error: out of bound pointer
TEST(error, assignFiles_test3)
{
    char arg[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    char _infile[2][2] = {{'c', 'a'}, {'a', 'a'}};
    char ** infile = (char **) calloc(3, sizeof(char *));
    for (int it_137_0 = 0; it_137_0 < 2; it_137_0 ++) {
        infile[it_137_0] = _infile[it_137_0];
    }
    infile[2] = NULL;
    char _outfile[2][2] = {{'a', 'c'}, {'c', 'a'}};
    char ** outfile = (char **) calloc(3, sizeof(char *));
    for (int it_138_0 = 0; it_138_0 < 2; it_138_0 ++) {
        outfile[it_138_0] = _outfile[it_138_0];
    }
    outfile[2] = NULL;
    struct stat statbuf = {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    };
    struct _BCoptions options = {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 99
    };
    char key[] = {'a', 'c', 'c', 'c', 'a', 'a', 'a', 'a', 'a', '\0'};
    assignFiles(arg, infile, outfile, &statbuf, &options, key);

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

#pragma endregion
}
