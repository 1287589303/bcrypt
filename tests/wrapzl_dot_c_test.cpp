/*
 * This file is automatically generated by UnitTestBot. For further information see https://www.utbot.org
 */

#include "wrapzl_dot_c_test.h"

#include "gtest/gtest.h"

namespace UTBot {


#pragma region regression
TEST(regression, douncompress_test1)
{
    char _input[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_155_0 = 0; it_155_0 < 2; it_155_0 ++) {
        input[it_155_0] = _input[it_155_0];
    }
    input[2] = NULL;
    unsigned long actual = douncompress(input, 3UL, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 72340172838076673UL,
        .securedelete = 99
    });
    EXPECT_EQ(0UL, actual);
    char expected_input[2][2] = {{'\0', '\0'}, {'\0', '\0'}};
    for (int it_156_0 = 0; it_156_0 < 2; it_156_0 ++) {
        for (int it_156_1 = 0; it_156_1 < 2; it_156_1 ++) {
            EXPECT_EQ(expected_input[it_156_0][it_156_1], _input[it_156_0][it_156_1]);
        }
    }
}

TEST(regression, douncompress_test2)
{
    char _input[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_157_0 = 0; it_157_0 < 2; it_157_0 ++) {
        input[it_157_0] = _input[it_157_0];
    }
    input[2] = NULL;
    unsigned long actual = douncompress(input, 3UL, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 7UL,
        .securedelete = 99
    });
    EXPECT_EQ(0UL, actual);
    char expected_input[2][2] = {{'\0', '\0'}, {'\0', '\0'}};
    for (int it_158_0 = 0; it_158_0 < 2; it_158_0 ++) {
        for (int it_158_1 = 0; it_158_1 < 2; it_158_1 ++) {
            EXPECT_EQ(expected_input[it_158_0][it_158_1], _input[it_158_0][it_158_1]);
        }
    }
}

#pragma endregion
#pragma region error
// Error: float-cast-overflow
TEST(error, docompress_test1)
{
    char _input[2][2] = {{'c', 'c'}, {'a', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_154_0 = 0; it_154_0 < 2; it_154_0 ++) {
        input[it_154_0] = _input[it_154_0];
    }
    input[2] = NULL;
    docompress(input, 17582193682821437184UL);

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

// Error: free of alloca
TEST(error, douncompress_test3)
{
    char _input[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_159_0 = 0; it_159_0 < 2; it_159_0 ++) {
        input[it_159_0] = _input[it_159_0];
    }
    input[2] = NULL;
    douncompress(input, 0UL, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 0UL,
        .securedelete = 99
    });

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

#pragma endregion
}
