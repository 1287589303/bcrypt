/*
 * This file is automatically generated by UnitTestBot. For further information see https://www.utbot.org
 */

#include "rwfile_dot_c_test.h"

#include "gtest/gtest.h"

namespace UTBot {


#pragma region regression
TEST(regression, getremain_test1)
{
    int actual = getremain(3UL, -5);
    EXPECT_EQ(0, actual);
}

TEST(regression, getremain_test2)
{
    int actual = getremain(4611686020574871552UL, 3);
    EXPECT_EQ(0, actual);
}

TEST(regression, padInput_test1)
{
    char _input[2][2] = {{'c', 'c'}, {'c', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_160_0 = 0; it_160_0 < 2; it_160_0 ++) {
        input[it_160_0] = _input[it_160_0];
    }
    input[2] = NULL;
    unsigned long actual = padInput(input, 0UL);
    EXPECT_EQ(0UL, actual);
    char expected_input[2][2] = {{'c', 'c'}, {'c', 'c'}};
    for (int it_161_0 = 0; it_161_0 < 2; it_161_0 ++) {
        for (int it_161_1 = 0; it_161_1 < 2; it_161_1 ++) {
            EXPECT_EQ(expected_input[it_161_0][it_161_1], _input[it_161_0][it_161_1]);
        }
    }
}

TEST(regression, attachKey_test1)
{
    char _input[2][2] = {{'a', 'c'}, {'c', 'a'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_163_0 = 0; it_163_0 < 2; it_163_0 ++) {
        input[it_163_0] = _input[it_163_0];
    }
    input[2] = NULL;
    char key[] = {'c', 'c', 'c', 'c', 'a', 'c', 'c', 'a', 'c', '\0'};
    unsigned long actual = attachKey(input, key, 72340172838076673UL);
    EXPECT_EQ(0UL, actual);
    char expected_input[2][2] = {{'\0', '\0'}, {'\0', '\0'}};
    for (int it_164_0 = 0; it_164_0 < 2; it_164_0 ++) {
        for (int it_164_1 = 0; it_164_1 < 2; it_164_1 ++) {
            EXPECT_EQ(expected_input[it_164_0][it_164_1], _input[it_164_0][it_164_1]);
        }
    }
    char expected_key[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_165_0 = 0; it_165_0 < 10; it_165_0 ++) {
        EXPECT_EQ(expected_key[it_165_0], key[it_165_0]);
    }
}

TEST(regression, readfile_test1)
{
    char infile[] = {'a', 'c', 'a', 'a', 'c', 'a', 'c', 'c', 'a', '\0'};
    char _input[2][2] = {{'c', 'c'}, {'a', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_168_0 = 0; it_168_0 < 2; it_168_0 ++) {
        input[it_168_0] = _input[it_168_0];
    }
    input[2] = NULL;
    char key[] = {'a', 'c', 'c', 'c', 'a', 'c', 'c', 'a', 'c', '\0'};
    unsigned long actual = readfile(infile, input, -5, key, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -2147505439L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(0UL, actual);
    char expected_infile[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_169_0 = 0; it_169_0 < 10; it_169_0 ++) {
        EXPECT_EQ(expected_infile[it_169_0], infile[it_169_0]);
    }
    char expected_input[2][2] = {{'\0', '\0'}, {'\0', '\0'}};
    for (int it_170_0 = 0; it_170_0 < 2; it_170_0 ++) {
        for (int it_170_1 = 0; it_170_1 < 2; it_170_1 ++) {
            EXPECT_EQ(expected_input[it_170_0][it_170_1], _input[it_170_0][it_170_1]);
        }
    }
    char expected_key[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_171_0 = 0; it_171_0 < 10; it_171_0 ++) {
        EXPECT_EQ(expected_key[it_171_0], key[it_171_0]);
    }
}

TEST(regression, writefile_test1)
{
    char outfile[] = {'c', '\0', 'a', 'c', 'a', 'a', 'c', 'c', 'c', '\0'};
    char output[] = {'a', 'c', 'a', 'c', 'c', 'a', 'a', 'c', 'c', '\0'};
    unsigned long actual = writefile(outfile, output, 3UL, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 99
    }, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(0UL, actual);
    char expected_outfile[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_172_0 = 0; it_172_0 < 10; it_172_0 ++) {
        EXPECT_EQ(expected_outfile[it_172_0], outfile[it_172_0]);
    }
    char expected_output[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_173_0 = 0; it_173_0 < 10; it_173_0 ++) {
        EXPECT_EQ(expected_output[it_173_0], output[it_173_0]);
    }
}

TEST(regression, deletefile_test1)
{
    char file[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    char key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    int actual = deletefile(file, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 0
    }, key, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(1, actual);
    char expected_file[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_174_0 = 0; it_174_0 < 10; it_174_0 ++) {
        EXPECT_EQ(expected_file[it_174_0], file[it_174_0]);
    }
    char expected_key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_175_0 = 0; it_175_0 < 10; it_175_0 ++) {
        EXPECT_EQ(expected_key[it_175_0], key[it_175_0]);
    }
}

TEST(regression, deletefile_test2)
{
    char file[] = {'c', '\0', 'c', 'a', 'c', 'c', 'a', 'c', 'c', '\0'};
    char key[] = {'a', 'a', 'a', 'a', 'c', 'c', 'a', 'a', 'c', '\0'};
    int actual = deletefile(file, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 0
    }, key, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(0, actual);
    char expected_file[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_176_0 = 0; it_176_0 < 10; it_176_0 ++) {
        EXPECT_EQ(expected_file[it_176_0], file[it_176_0]);
    }
    char expected_key[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_177_0 = 0; it_177_0 < 10; it_177_0 ++) {
        EXPECT_EQ(expected_key[it_177_0], key[it_177_0]);
    }
}

TEST(regression, deletefile_test3)
{
    char file[] = {'c', 'c', 'c', 'a', 'c', 'c', 'a', 'c', 'c', '\0'};
    char key[] = {'a', 'a', 'a', 'a', 'c', 'c', 'a', 'a', 'c', '\0'};
    int actual = deletefile(file, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 112
    }, key, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(0, actual);
    char expected_file[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_178_0 = 0; it_178_0 < 10; it_178_0 ++) {
        EXPECT_EQ(expected_file[it_178_0], file[it_178_0]);
    }
    char expected_key[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_179_0 = 0; it_179_0 < 10; it_179_0 ++) {
        EXPECT_EQ(expected_key[it_179_0], key[it_179_0]);
    }
}

TEST(regression, deletefile_test4)
{
    char file[] = {'c', 'c', 'c', 'a', 'c', 'c', 'a', 'c', 'c', '\0'};
    char key[] = {'a', 'a', 'a', 'a', 'c', 'c', 'a', 'a', 'c', '\0'};
    int actual = deletefile(file, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 112
    }, key, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -4611687117939015751L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(0, actual);
    char expected_file[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_180_0 = 0; it_180_0 < 10; it_180_0 ++) {
        EXPECT_EQ(expected_file[it_180_0], file[it_180_0]);
    }
    char expected_key[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'};
    for (int it_181_0 = 0; it_181_0 < 10; it_181_0 ++) {
        EXPECT_EQ(expected_key[it_181_0], key[it_181_0]);
    }
}

TEST(regression, deletefile_test5)
{
    char file[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    char key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    int actual = deletefile(file, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 0
    }, key, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });
    EXPECT_EQ(0, actual);
    char expected_file[] = {'C', '\0', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_182_0 = 0; it_182_0 < 10; it_182_0 ++) {
        EXPECT_EQ(expected_file[it_182_0], file[it_182_0]);
    }
    char expected_key[] = {'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', 'c', '\0'};
    for (int it_183_0 = 0; it_183_0 < 10; it_183_0 ++) {
        EXPECT_EQ(expected_key[it_183_0], key[it_183_0]);
    }
}

#pragma endregion
#pragma region error
// Error: integer division overflow
TEST(error, getremain_test3)
{
    getremain(3UL, 0);

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

// Error: memory error: out of bound pointer
TEST(error, padInput_test2)
{
    char _input[2][2] = {{'a', 'c'}, {'c', 'c'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_162_0 = 0; it_162_0 < 2; it_162_0 ++) {
        input[it_162_0] = _input[it_162_0];
    }
    input[2] = NULL;
    padInput(input, 7UL);

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

// Error: free of alloca
TEST(error, attachKey_test2)
{
    char _input[2][2] = {{'a', 'c'}, {'c', 'a'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_166_0 = 0; it_166_0 < 2; it_166_0 ++) {
        input[it_166_0] = _input[it_166_0];
    }
    input[2] = NULL;
    char key[] = {'c', 'c', 'c', 'c', 'a', 'c', 'c', 'a', 'c', '\0'};
    attachKey(input, key, 18446744073709551557UL);

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

// Error: memory error: out of bound pointer
TEST(error, attachKey_test3)
{
    char _input[2][2] = {{'a', 'c'}, {'c', 'a'}};
    char ** input = (char **) calloc(3, sizeof(char *));
    for (int it_167_0 = 0; it_167_0 < 2; it_167_0 ++) {
        input[it_167_0] = _input[it_167_0];
    }
    input[2] = NULL;
    char key[] = {'c', 'c', 'c', 'c', 'a', 'c', 'c', 'a', 'c', '\0'};
    attachKey(input, key, 0UL);

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

// Error: memory error: out of bound pointer
TEST(error, writefile_test2)
{
    char outfile[] = {'C', '\0', 'a', 'c', 'a', 'a', 'c', 'c', 'c', '\0'};
    char output[] = {'a', 'c', 'a', 'c', 'c', 'a', 'a', 'c', 'c', '\0'};
    writefile(outfile, output, 72340172838077122UL, {
        .remove = 99,
        .standardout = 99,
        .compression = 99,
        .type = 99,
        .origsize = 3UL,
        .securedelete = 99
    }, {
        .st_dev = 3UL,
        .st_ino = 3UL,
        .st_nlink = 3UL,
        .st_mode = 3U,
        .st_uid = 3U,
        .st_gid = 3U,
        .__pad0 = -5,
        .st_rdev = 3UL,
        .st_size = -5L,
        .st_blksize = -5L,
        .st_blocks = -5L,
        .st_atim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_mtim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .st_ctim = {
            .tv_sec = -5L,
            .tv_nsec = -5L
        },
        .__glibc_reserved = {-5L, -5L, -5L}
    });

    FAIL() << "Unreachable point or the function was supposed to fail, but "
        "actually completed successfully. See the SARIF report for details.";
}

#pragma endregion
}
